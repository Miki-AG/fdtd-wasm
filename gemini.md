# Gemini CLI Preferences Summary

This document summarizes the user's preferences and established conventions during our interaction, to guide future tasks.

## 1. Core Technologies & Languages
- **Backend/Library:** Rust
- **Web Integration:** WebAssembly (Wasm) with `wasm-bindgen`
- **Frontend/Scripting:** Node.js (JavaScript) for web applications and tooling (e.g., test reports). **Python is not preferred for scripting.**

## 2. Development Workflow
- **Phased Approach:** Strict adherence to a 3-phase development cycle:
    1.  **Phase 1: Architecture & Design:** Focus on defining module structure, public function signatures, and data structures. Deliverables should be compilable code with `todo!()` macros or empty bodies; no logic implementation.
    2.  **Phase 2: Test-Driven Setup:** Develop comprehensive test cases for all defined public APIs. Create an HTML test report that initially shows 100% test failures.
    3.  **Phase 3: Implementation & Green Build:** Incrementally implement functions, aiming to make tests pass one by one until all functional tests are green.

## 3. Test Reporting
- **Format:** HTML report generated by a Node.js script (`generate_report.js`).
- **Content:**
    -   Lists all public API functions, grouped logically by module (e.g., Parameters, State, Engine).
    -   Shows test status for each API: "Pass", "Fail", "No Test", "Test Written (Not Run/Wasm)".
    -   Expected failures (e.g., WASM binding tests run on a native host) should be clearly marked (e.g., grayed out with "Expected Fail (WASM)" status).
    -   Excludes "Type" column in API tables.
    -   Excludes "Raw Cargo Test Output" by default (unless specifically requested for debugging).
- **Layout:**
    -   Compact design: smaller fonts, reduced margins/padding.
    -   3-column flexbox layout for module groups (e.g., Col 1: Parameters, State, Rasterizer; Col 2: Renderer, Engine, Step; Col 3: Lib, Utils, Comms).
- **Features:** Includes an auto-refresh toggle button for the report page.

## 4. Code Style & Conventions
- **Rust:** Adhere to idiomatic Rust. Explicit `use` statements. Clear `todo!()` for unimplemented sections.
- **JavaScript:** ES module syntax (`import`, `export`). Clear separation of concerns (WASM bindings, UI logic, helper functions).

## 5. Simulation Specifics (for `fdtd-wasm` project)
- **Core:** 2D FDTD simulation library.
- **Visualization:** HTML5 Canvas, black background.
    -   Electric field: Red for positive values, Blue for negative values, Black for zero.
    -   Obstacles: Painted Green.
    -   Emitter/Receiver: Small white circles with red/blue outlines respectively.
- **Input/Controls:**
    -   Configurable simulation space, source position/amplitude/frequency/type, and SVG-defined obstacles.
    -   Selectable source signal types (Continuous Sine, Continuous Square, Pulse Sine, Pulse Square).
    -   Selectable scenarios (Simple Box, Free Space, Double Parabolic Antenna).
    -   Gain slider for received signal plot.
- **Communication Module (Comms):**
    -   Packet-based digital communication: Preamble, Sync, Length, Payload, CRC.
    -   Selectable Modulation Scheme: FSK (Frequency Shift Keying) / ASK (Amplitude Shift Keying).
    -   Real-time display of transmitted bits (Tx), received bits (Rx), decoded text, and demodulator packet state.
    -   Real-time received signal plot (scope view).
    -   Real-time Received Signal FFT view.
    -   Demodulation includes squelch/threshold to filter out noise/silence.
    -   Sending a message automatically starts the simulation.
